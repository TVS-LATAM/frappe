import os
import re
from io import BytesIO

from pypdf import PdfWriter

import frappe
from frappe import _
from frappe.core.doctype.access_log.access_log import make_access_log
from frappe.translate import print_language
from frappe.utils.deprecations import deprecated
from frappe.utils.pdf import get_pdf

no_cache = 1

base_template_path = "www/printview.html"
standard_format = "templates/print_formats/standard.html"

from frappe.www.printview import validate_print_permission


@frappe.whitelist()
def download_multi_pdf(
    doctype, name, format=None, no_letterhead=False, letterhead=None, options=None
):
    """
    Concatenate multiple docs as PDF .

    Returns a PDF compiled by concatenating multiple documents. The documents
    can be from a single DocType or multiple DocTypes

    Note: The design may seem a little weird, but it exists exists to
            ensure backward compatibility. The correct way to use this function is to
            pass a dict to doctype as described below

    NEW FUNCTIONALITY
    =================
    Parameters:
    doctype (dict):
            key (string): DocType name
            value (list): of strings of doc names which need to be concatenated and printed
    name (string):
            name of the pdf which is generated
    format:
            Print Format to be used

    Returns:
    PDF: A PDF generated by the concatenation of the mentioned input docs

    OLD FUNCTIONALITY - soon to be deprecated
    =========================================
    Parameters:
    doctype (string):
            name of the DocType to which the docs belong which need to be printed
    name (string or list):
            If string the name of the doc which needs to be printed
            If list the list of strings of doc names which needs to be printed
    format:
            Print Format to be used

    Returns:
    PDF: A PDF generated by the concatenation of the mentioned input docs
    """

    import json

    pdf_writer = PdfWriter()

    if isinstance(options, str):
        options = json.loads(options)

    if not isinstance(doctype, dict):
        result = json.loads(name)

        # Concatenating pdf files
        for i, ss in enumerate(result):
            pdf_writer = frappe.get_print(
                doctype,
                ss,
                format,
                as_pdf=True,
                output=pdf_writer,
                no_letterhead=no_letterhead,
                letterhead=letterhead,
                pdf_options=options,
            )
        frappe.local.response.filename = "{doctype}.pdf".format(
            doctype=doctype.replace(" ", "-").replace("/", "-")
        )
    else:
        for doctype_name in doctype:
            for doc_name in doctype[doctype_name]:
                try:
                    pdf_writer = frappe.get_print(
                        doctype_name,
                        doc_name,
                        format,
                        as_pdf=True,
                        output=pdf_writer,
                        no_letterhead=no_letterhead,
                        letterhead=letterhead,
                        pdf_options=options,
                    )
                except Exception:
                    frappe.log_error(
                        title="Error in Multi PDF download",
                        message=f"Permission Error on doc {doc_name} of doctype {doctype_name}",
                        reference_doctype=doctype_name,
                        reference_name=doc_name,
                    )
        frappe.local.response.filename = f"{name}.pdf"

    with BytesIO() as merged_pdf:
        pdf_writer.write(merged_pdf)
        frappe.local.response.filecontent = merged_pdf.getvalue()

    frappe.local.response.type = "pdf"


@deprecated
def read_multi_pdf(output: PdfWriter) -> bytes:
    with BytesIO() as merged_pdf:
        output.write(merged_pdf)
        return merged_pdf.getvalue()


def capitalize_first_letter(text):
    if not text:
        return text
    return " ".join(word.capitalize() for word in text.split())

def extract_address_details(text):
    # Define patterns for the address components
    address_pattern = r"Address Line 1 (.*?)<br>"
    zip_code_pattern = r"(\d{5,6})<br>"
    city_pattern = r"City/Town (.*?)<br>"
    country_pattern = r"(\w+)<br>"

    # Extract the components using the patterns
    address = re.search(address_pattern, text)
    zip_code = re.search(zip_code_pattern, text)
    city = re.search(city_pattern, text)
    country = re.search(country_pattern, text)

    # Get the matched strings or None if not found
    address = address.group(1) if address else ""
    zip_code = zip_code.group(1) if zip_code else ""
    city = city.group(1) if city else None
    country = country.group(1) if country else ""
    obj = {
        "address": address,
        "zip_code": zip_code,
        "city": city,
        "country": country
    }
    return obj
    
def format_address_detail_to_print(text):
    address = text['address'] if 'address' in text else ""
    zip_code = text['zip_code'] if 'zip_code' in text else ""
    city = text['city'] if 'city' in text else ""
    country = text['country'] if 'country' in text else ""
    return f"{address}<br>{zip_code} {city}<br>{country}"

def convert_to_int(value):
    try:
        # Convert the value to a float first to handle both numeric strings and numbers
        float_value = float(value)
        # Convert the float value to an integer
        int_value = int(float_value)
        return int_value
    except ValueError:
        # If the value cannot be converted to a float, raise an error
        raise ValueError("The input value is not a number or a numeric string")

@frappe.whitelist(allow_guest=True)
def download_pdf(
    doctype, name, format=None, doc=None, no_letterhead=0, language=None, letterhead=None
):
    doc = doc or frappe.get_doc(doctype, name)
    items_custom = []
    if((doc.get("doctype") == "Quotation" or doc.get("doctype") == "Sales Invoice")):
        for item in doc.get("items"):
            if(doc.get("doctype") == "Sales Invoice"):
                value = frappe.get_doc("Sales Invoice Item", item.name)
            if(doc.get("doctype") == "Quotation"):
                value = frappe.get_doc("Quotation Item", item.name)
            items_custom.append({
                    "item_code": value.get("item_code"),
                    "item_name": value.get("item_name"),
                    "description": value.get("description"),
                    "brand": value.get("brand"),
                    "base_amount": value.get("base_amount"),
                    "tvs_pn": value.get("tvs_pn") or "",
                    "qty": convert_to_int(value.get("qty")),
                    "rate": value.get("rate")
                    })
        doc.items_custom = items_custom
    if doc.get("customer_name"):
        doc.customer_name = capitalize_first_letter(doc.get("customer_name"))
        
    if doc.get("doctype") in ["Quotation", "Sales Invoice"]:
        if doc.get("billing_address"):
            address_data = extract_address_details(doc.get("billing_address"))
        elif doc.get("shipping_address"):
            address_data = extract_address_details(doc.get("shipping_address"))
        elif doc.get("address_display"):
            address_data = extract_address_details(doc.get("address_display"))
        else:
            address_data = None

        if address_data:
            address_formated = format_address_detail_to_print(address_data)
            doc.address_display = address_formated
            doc.is_address_formated = True


    validate_print_permission(doc)

    with print_language(language):
        pdf_file = frappe.get_print(
            doctype,
            name,
            format,
            doc=doc,
            as_pdf=True,
            letterhead=letterhead,
            no_letterhead=no_letterhead,
        )

    frappe.local.response.filename = "{name}.pdf".format(
        name=name.replace(" ", "-").replace("/", "-")
    )
    frappe.local.response.filecontent = pdf_file
    frappe.local.response.type = "pdf"


@frappe.whitelist()
def report_to_pdf(html, orientation="Landscape"):
    make_access_log(file_type="PDF", method="PDF", page=html)
    frappe.local.response.filename = "report.pdf"
    frappe.local.response.filecontent = get_pdf(html, {"orientation": orientation})
    frappe.local.response.type = "pdf"


@frappe.whitelist()
def print_by_server(
    doctype, name, printer_setting, print_format=None, doc=None, no_letterhead=0, file_path=None
):
    print_settings = frappe.get_doc("Network Printer Settings", printer_setting)
    try:
        import cups
    except ImportError:
        frappe.throw(_("You need to install pycups to use this feature!"))

    try:
        cups.setServer(print_settings.server_ip)
        cups.setPort(print_settings.port)
        conn = cups.Connection()
        output = PdfWriter()
        output = frappe.get_print(
            doctype,
            name,
            print_format,
            doc=doc,
            no_letterhead=no_letterhead,
            as_pdf=True,
            output=output,
        )
        if not file_path:
            file_path = os.path.join("/", "tmp", f"frappe-pdf-{frappe.generate_hash()}.pdf")
        output.write(open(file_path, "wb"))
        conn.printFile(print_settings.printer_name, file_path, name, {})
    except OSError as e:
        if (
            "ContentNotFoundError" in e.message
            or "ContentOperationNotPermittedError" in e.message
            or "UnknownContentError" in e.message
            or "RemoteHostClosedError" in e.message
        ):
            frappe.throw(_("PDF generation failed"))
    except cups.IPPError:
        frappe.throw(_("Printing failed"))
